#SET INITIAL STATES AND PARAMETERS
num_S <- 9999
num_I <- 1
num_R <- 0
beta <- 2 #infection rate
mu = 1 #recovery rate
N <- num_S + num_I + num_R #total population
S <- num_S
I <- num_I
R <- num_R
S_vals <- c(S)
I_vals <- c(I)
R_vals <- c(R)
time <- c(t)
while (t < tf) {
if (I == 0) {
break
}
infection_rate <- beta * I * S / N
recovery_rate <- mu * I
total_rate <- infection_rate + recovery_rate
dt <- -log(runif(1, min=0, max=1)) / total_rate
t = t + dt
if (runif(1, min=0, max=1) < infection_rate / total_rate) {
I <- I + 1
S <- S - 1
}
else {
I <- I - 1
R <- R + 1
}
S_vals <- c(S_vals, S)
I_vals <- c(I_vals, I)
R_vals <- c(R_vals, R)
time <- c(time, t)
}
run_df <- data.frame(time, S_vals, I_vals, R_vals)
#find S, I and R levels at set times and put in data frame to return from function
run.I.times <- approx(x = run_df$time,
y = run_df$I_vals,
xout = time_points,
method = "constant")
run.I.times.df <- data.frame(run.I.times[1], run.I.times[2])
colnames(run.I.times.df) <- c("time", "num_infected")
trajectory[[1]]
#FUNCTION TO IMPLEMENT GILLESPIE ALGORITHM AND RETURN NUMBERS OF S, I, R AT TIMEPOINTS
run_simulation <- function(t, tf, num_I, num_S, num_R, N) {
S <- num_S
I <- num_I
R <- num_R
S_vals <- c(S)
I_vals <- c(I)
R_vals <- c(R)
time <- c(t)
while (t < tf) {
if (I == 0) {
break
}
infection_rate <- beta * I * S / N
recovery_rate <- mu * I
total_rate <- infection_rate + recovery_rate
dt <- -log(runif(1, min=0, max=1)) / total_rate
t = t + dt
if (runif(1, min=0, max=1) < infection_rate / total_rate) {
I <- I + 1
S <- S - 1
}
else {
I <- I - 1
R <- R + 1
}
S_vals <- c(S_vals, S)
I_vals <- c(I_vals, I)
R_vals <- c(R_vals, R)
time <- c(time, t)
}
run_df <- data.frame(time, S_vals, I_vals, R_vals)
#find S, I and R levels at set times and put in data frame to return from function
run.I.times <- approx(x = run_df$time,
y = run_df$I_vals,
xout = time_points,
method = "constant")
run.I.times.df <- data.frame(run.I.times[1], run.I.times[2])
colnames(run.I.times.df) <- c("time", "num_infected")
run.S.times <- approx(x = run_df$time,
y = run_df$S_vals,
xout = time_points,
method = "constant")
run.S.times.df <- data.frame(run.S.times[1], run.S.times[2])
colnames(run.S.times.df) <- c("time", "num_susceptible")
run.R.times <- approx(x = run_df$time,
y = run_df$R_vals,
xout = time_points,
method = "constant")
run.R.times.df <- data.frame(run.R.times[1], run.R.times[2])
colnames(run.R.times.df) <- c("time", "num_recovered")
return(list(run.I.times.df, run.S.times.df, run.R.times.df))
}
trajectory <- run_simulation(t, tf, num_I, num_S, num_R, N)
I_times <- trajectory[[1]]
S_times <- trajectory[[2]]
R_times <- trajectory[[3]]
trajectory[1]
bum_I
num_I
trajectory[1]
infection_rate <- beta * I * S / N
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
# delete everything
rm(list=ls(all=TRUE))
# import library for implementing Gillespie's algorithm
require(adaptivetau)
require(deSolve)
#SET TIMEFRAME FOR MODEL
t <- 0 #start time
tf <- 10
time_points <- seq(0, tf, by = 0.5)
num_runs <- 10
#SET INITIAL STATES AND PARAMETERS
num_S <- 9999
num_I <- 1
num_R <- 0
beta <- 2 #infection rate
mu = 1 #recovery rate
N <- num_S + num_I + num_R #total population
#FUNCTION TO IMPLEMENT GILLESPIE ALGORITHM AND RETURN NUMBERS OF S, I, R AT TIMEPOINTS
run_simulation <- function(t, tf, num_I, num_S, num_R, N, beta, mu) {
S <- num_S
I <- num_I
R <- num_R
S_vals <- c(S)
I_vals <- c(I)
R_vals <- c(R)
time <- c(t)
while (t < tf) {
if (I == 0) {
break
}
infection_rate <- beta * I * S / N
recovery_rate <- mu * I
total_rate <- infection_rate + recovery_rate
dt <- -log(runif(1, min=0, max=1)) / total_rate
t = t + dt
if (runif(1, min=0, max=1) < infection_rate / total_rate) {
I <- I + 1
S <- S - 1
}
else {
I <- I - 1
R <- R + 1
}
S_vals <- c(S_vals, S)
I_vals <- c(I_vals, I)
R_vals <- c(R_vals, R)
time <- c(time, t)
}
run_df <- data.frame(time, S_vals, I_vals, R_vals)
#find S, I and R levels at set times and put in data frame to return from function
run.I.times <- approx(x = run_df$time,
y = run_df$I_vals,
xout = time_points,
method = "constant")
run.I.times.df <- data.frame(run.I.times[1], run.I.times[2])
colnames(run.I.times.df) <- c("time", "num_infected")
run.S.times <- approx(x = run_df$time,
y = run_df$S_vals,
xout = time_points,
method = "constant")
run.S.times.df <- data.frame(run.S.times[1], run.S.times[2])
colnames(run.S.times.df) <- c("time", "num_susceptible")
run.R.times <- approx(x = run_df$time,
y = run_df$R_vals,
xout = time_points,
method = "constant")
run.R.times.df <- data.frame(run.R.times[1], run.R.times[2])
colnames(run.R.times.df) <- c("time", "num_recovered")
return(list(run.I.times.df, run.S.times.df, run.R.times.df))
}
trajectory <- run_simulation(t, tf, num_I, num_S, num_R, N, beta, mu)
View(trajectory)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
trajectory <- run_simulation(t, tf, num_I, num_S, num_R, N, beta, mu)
run_df <- data.frame(time, S_vals, I_vals, R_vals)
View(run_df)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
time_points <- seq(0, tf, by = 0.5)
time_points <- seq(0, tf, by = 0.5)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
# delete everything
rm(list=ls(all=TRUE))
# delete everything
rm(list=ls(all=TRUE))
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
run_df <- data.frame(time, S_vals, I_vals, R_vals)
?approx
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
View(run.I.times)
View(trajectory)
View(trajectory)
View(I_times)
View(S_times)
View(trajectory)
View(trajectory)
View(run_df)
View(run.I.times)
View(I_simulations)
View(I_simulations)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
View(I_simulations)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
recovery_rate <- mu * I
recovery_rate <- mu * I
recovery_rate <- mu * I
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SI_model/SI_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SI_model/SI_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SI_model/SI_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SI_model/SI_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SI_model/SI_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SI_model/SI_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SI_model/SI_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SI_model/SI_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SI_model/SI_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
library(flux)
?flux
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
View(trajectory_df)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
View(trajectory_df)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Stochastic_model/2_patch_stochast.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Stochastic_model/2_patch_stochast.R', echo=TRUE)
data = c(1,2,3,4)
data <- list(height = c(1,2,3), length = c(1,2,3))
data
datan <- filter(data, height <2)
datan <- filter(data[1], height <2)
datan <- filter(data[[1]], height <2)
data <- data.base(height = c(1,2,3), length = c(1,2,3))
data <- data.frame(height = c(1,2,3), length = c(1,2,3))
data_f <- filter(data, height <2)
data
data_f <- filter(data$height <2)
head(data)
data$height
data$height <2
filter(data, height <2)
filter(data, data$height <2)
install.packages(dplyr)
install.packages('dplyr')
library(dplyr)
filter(data, height <2)
filter(data, height != 2)
getwd()
setwd("/Users/elinfalla/2")
setwd("/Users/elinfalla/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/")
file.edit("tmp.R")
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/tmp.R', echo=TRUE)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/tmp.R', echo=TRUE)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/tmp.R', echo=TRUE)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/tmp.R', echo=TRUE)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/tmp.R', echo=TRUE)
file.edit("DataWrang.R")
dim(MyData)
str(MyData)
?str
fix(MyData)
?t
t(MyData)
TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
view(TempData)
TempData
?melt
??melt
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/DataWrang.R', echo=TRUE)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/DataWrang.R', echo=TRUE)
require(tidyverse)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/DataWrang.R', echo=TRUE)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/DataWrang.R', echo=TRUE)
?tibble
?tibble::as.tibble
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/DataWrang.R', echo=TRUE)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/DataWrang.R', echo=TRUE)
dlpyr::slice(MyWrangledData, 10:15) # Look at an arbitrary set of data rows
dplyr::slice(MyWrangledData, 10:15) # Look at an arbitrary set of data rows
file.edit("Basic_plotting.R")
file.edit("TreeHeight.R")
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/Basic_plotting.R', echo=TRUE)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/Basic_plotting.R', echo=TRUE)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/Basic_plotting.R', echo=TRUE)
plot(MyDF$Predator.mass, MyDF$Prey.mass)
plot(log(MyDF$Predator.mass), log(MyDF$Prey.mass))
plot(log10(MyDF$Predator.mass), log10(MyDF$Prey.mass))
plot(log10(MyDF$Predator.mass), log10(MyDF$Prey.mass), pch=20,
xlab = "Predator Mass (g)", ylab = "Prey mass (g)")
plot(log10(MyDF$Predator.mass), log10(MyDF$Prey.mass), pch=20,
xlab = "Predator Mass (g)", ylab = "Prey mass (g)")
hist(MyDF$Predator.mass)
hist(log10(MyDF$Predator.mass),
xlab = "log10(Predator mass (g))",
ylab = "Count")
hist(log10(MyDF$Predator.mass),
xlab = "log10(Predator mass (g))",
ylab = "Count",
col = "lightblue",
border = "pink")
hist(log10(MyDF$Prey.mass),
xlab = "log10(Prey mass (g))",
ylab = "Count",
col = "red",
border = "black")
hist(log10(MyDF$Predator.mass),
xlab = "log10(Predator mass (g))",
ylab = "Count",
col = "lightblue",
border = "pink")
hist(log10(MyDF$Prey.mass),
xlab = "log10(Prey mass (g))",
ylab = "Count",
col = "red",
border = "black")
?hist
hist(log10(MyDF$Prey.mass),
breaks = 10,
xlab = "log10(Prey mass (g))",
ylab = "Count",
col = "red",
border = "black",
xlim = c(min(MyDF$Prey.mass), max(MyDF$Prey.mass))
)
hist(log10(MyDF$Prey.mass),
breaks = 10,
xlab = "log10(Prey mass (g))",
ylab = "Count",
col = "red",
border = "black",
xlim = c(min(MyDF$Prey.mass), max(MyDF$Prey.mass))
)
#Adjust axes limits and set number of histogram bins (cols)
hist(log10(MyDF$Prey.mass),
breaks = 10,
xlab = "log10(Prey mass (g))",
ylab = "Count",
col = "red",
border = "black",
xlim = c(minlog10((MyDF$Prey.mass)), max(log10(MyDF$Prey.mass)))
)
hist(log10(MyDF$Prey.mass),
breaks = 10,
xlab = "log10(Prey mass (g))",
ylab = "Count",
col = "red",
border = "black",
xlim = c(min(log10(MyDF$Prey.mass)), max(log10(MyDF$Prey.mass)))
)
hist(log10(MyDF$Prey.mass),
breaks = 20,
xlab = "log10(Prey mass (g))",
ylab = "Count",
col = "red",
border = "black",
xlim = c(min(log10(MyDF$Prey.mass)), max(log10(MyDF$Prey.mass)))
)
hist(log10(MyDF$Predator.mass),
breaks = 20,
xlab = "log10(Prey mass (g))",
ylab = "Count",
col = "blue",
border = "black",
xlim = c(min(log10(MyDF$Predator.mass)), max(log10(MyDF$Predator.mass)))
)
par(mfcol=c(2,1)) # initialise multi-paneled plot
par(mfg - c(1,1)) # specify which subplot to use first
hist(log10(MyDF$Predator.mass),
xlab = "log10(Predator Mass (g))",
ylab = "Count",
col = "lightblue",
border = "pink",
main = "Predator"
)
par(mfg = c(2,1)) #Second subplot
hist(log10(MyDF$Prey.mass),
xlab = "log10(Prey Mass (g))",
ylab = "Count",
col = "lightgreen",
border = "pink",
main = "Prey"
)
hist(log10(MyDF$Predator.mass),
xlab="log10(Body Mass (g))",
ylab="Count",
col = rgb(1, 0, 0, 0.5), #Note fourth value is transparency
main = "Predator-prey size overlap"
)
hist(log10(MyDF$Prey.mass),
col = rgb(0, 0, 1, 0.5),
add = T
)
#Create legend
legend("topleft", c(Predators, Prey),
fill = c(rgb(1, 0, 0, 0.5), rgb(0, 0, 1, 0.5))
)
par(mfg = c(1,1))
hist(log10(MyDF$Predator.mass),
xlab="log10(Body Mass (g))",
ylab="Count",
col = rgb(1, 0, 0, 0.5), #Note fourth value is transparency
main = "Predator-prey size overlap"
)
hist(log10(MyDF$Prey.mass),
col = rgb(0, 0, 1, 0.5),
add = T
)
#Create legend
legend("topleft", c(Predators, Prey),
fill = c(rgb(1, 0, 0, 0.5), rgb(0, 0, 1, 0.5))
)
par(mfcol=c(1,1))
hist(log10(MyDF$Predator.mass),
xlab="log10(Body Mass (g))",
ylab="Count",
col = rgb(1, 0, 0, 0.5), #Note fourth value is transparency
main = "Predator-prey size overlap"
)
hist(log10(MyDF$Prey.mass),
col = rgb(0, 0, 1, 0.5),
add = T
)
#Create legend
legend("topleft", c(Predators, Prey),
fill = c(rgb(1, 0, 0, 0.5), rgb(0, 0, 1, 0.5))
)
#See if predator and prey mass distribuations are similar by overlaying
par(mfcol=c(1,1))
hist(log10(MyDF$Predator.mass),
xlab="log10(Body Mass (g))",
ylab="Count",
col = rgb(1, 0, 0, 0.5), #Note fourth value is transparency
main = "Predator-prey size overlap"
)
hist(log10(MyDF$Prey.mass),
col = rgb(0, 0, 1, 0.5),
add = T
)
#Create legend
legend("topleft", c("Predators", "Prey"),
fill = c(rgb(1, 0, 0, 0.5), rgb(0, 0, 1, 0.5))
)
file.edit("TreeHeight.R")
