else {
I <- I - 1
R <- R + 1
}
S_vals <- c(S_vals, S)
I_vals <- c(I_vals, I)
R_vals <- c(R_vals, R)
time <- c(time, t)
}
run_df <- data.frame(time, S_vals, I_vals, R_vals)
#find S, I and R levels at set times and put in data frame to return from function
run.I.times <- approx(x = run_df$time,
y = run_df$I_vals,
xout = time_points,
method = "constant")
run.I.times.df <- data.frame(run.I.times[1], run.I.times[2])
colnames(run.I.times.df) <- c("time", "num_infected")
run.S.times <- approx(x = run_df$time,
y = run_df$S_vals,
xout = time_points,
method = "constant")
run.S.times.df <- data.frame(run.S.times[1], run.S.times[2])
colnames(run.S.times.df) <- c("time", "num_susceptible")
run.R.times <- approx(x = run_df$time,
y = run_df$R_vals,
xout = time_points,
method = "constant")
run.R.times.df <- data.frame(run.R.times[1], run.R.times[2])
colnames(run.R.times.df) <- c("time", "num_recovered")
return(list(run.I.times.df, run.S.times.df, run.R.times.df))
}
trajectory <- run_simulation(t, tf, num_I, num_S, num_R, N)
I_times <- trajectory[[1]]
S_times <- trajectory[[2]]
R_times <- trajectory[[3]]
#simulations matrix: rows are time and columns are runs
I_matrix <- matrix(I_times$num_infected, ncol=1)
S_matrix <- matrix(S_times$num_susceptible, ncol=1)
R_matrix <- matrix(R_times$num_recovered, ncol=1)
View(I_times)
View(trajectory)
# delete everything
rm(list=ls(all=TRUE))
# import library for implementing Gillespie's algorithm
require(adaptivetau)
require(deSolve)
#SET TIMEFRAME FOR MODEL
t <- 0 #start time
tf <- 10
time_points <- seq(0, tf, by = 0.5)
num_runs <- 10
#SET INITIAL STATES AND PARAMETERS
num_S <- 9999
num_I <- 1
num_R <- 0
beta <- 2 #infection rate
mu = 1 #recovery rate
N <- num_S + num_I + num_R #total population
#FUNCTION TO IMPLEMENT GILLESPIE ALGORITHM AND RETURN NUMBERS OF S, I, R AT TIMEPOINTS
run_simulation <- function(t, tf, num_I, num_S, num_R, N) {
S <- num_S
I <- num_I
R <- num_R
S_vals <- c(S)
I_vals <- c(I)
R_vals <- c(R)
time <- c(t)
while (t < tf) {
if (I == 0) {
break
}
infection_rate <- beta * I * S / N
recovery_rate <- mu * I
total_rate <- infection_rate + recovery_rate
dt <- -log(runif(1, min=0, max=1)) / total_rate
t = t + dt
if (runif(1, min=0, max=1) < infection_rate / total_rate) {
I <- I + 1
S <- S - 1
}
else {
I <- I - 1
R <- R + 1
}
S_vals <- c(S_vals, S)
I_vals <- c(I_vals, I)
R_vals <- c(R_vals, R)
time <- c(time, t)
}
run_df <- data.frame(time, S_vals, I_vals, R_vals)
#find S, I and R levels at set times and put in data frame to return from function
run.I.times <- approx(x = run_df$time,
y = run_df$I_vals,
xout = time_points,
method = "constant")
run.I.times.df <- data.frame(run.I.times[1], run.I.times[2])
colnames(run.I.times.df) <- c("time", "num_infected")
run.S.times <- approx(x = run_df$time,
y = run_df$S_vals,
xout = time_points,
method = "constant")
run.S.times.df <- data.frame(run.S.times[1], run.S.times[2])
colnames(run.S.times.df) <- c("time", "num_susceptible")
run.R.times <- approx(x = run_df$time,
y = run_df$R_vals,
xout = time_points,
method = "constant")
run.R.times.df <- data.frame(run.R.times[1], run.R.times[2])
colnames(run.R.times.df) <- c("time", "num_recovered")
return(list(run.I.times.df, run.S.times.df, run.R.times.df))
}
trajectory <- run_simulation(t, tf, num_I, num_S, num_R, N)
trjectory[1]
trajectory[1]
# delete everything
rm(list=ls(all=TRUE))
# import library for implementing Gillespie's algorithm
require(adaptivetau)
require(deSolve)
#SET TIMEFRAME FOR MODEL
t <- 0 #start time
tf <- 10
time_points <- seq(0, tf, by = 0.5)
num_runs <- 10
#SET INITIAL STATES AND PARAMETERS
num_S <- 9999
num_I <- 1
num_R <- 0
beta <- 2 #infection rate
mu = 1 #recovery rate
N <- num_S + num_I + num_R #total population
S <- num_S
I <- num_I
R <- num_R
S_vals <- c(S)
I_vals <- c(I)
R_vals <- c(R)
time <- c(t)
while (t < tf) {
if (I == 0) {
break
}
infection_rate <- beta * I * S / N
recovery_rate <- mu * I
total_rate <- infection_rate + recovery_rate
dt <- -log(runif(1, min=0, max=1)) / total_rate
t = t + dt
if (runif(1, min=0, max=1) < infection_rate / total_rate) {
I <- I + 1
S <- S - 1
}
else {
I <- I - 1
R <- R + 1
}
S_vals <- c(S_vals, S)
I_vals <- c(I_vals, I)
R_vals <- c(R_vals, R)
time <- c(time, t)
}
run_df <- data.frame(time, S_vals, I_vals, R_vals)
#find S, I and R levels at set times and put in data frame to return from function
run.I.times <- approx(x = run_df$time,
y = run_df$I_vals,
xout = time_points,
method = "constant")
run.I.times.df <- data.frame(run.I.times[1], run.I.times[2])
colnames(run.I.times.df) <- c("time", "num_infected")
trajectory[[1]]
#FUNCTION TO IMPLEMENT GILLESPIE ALGORITHM AND RETURN NUMBERS OF S, I, R AT TIMEPOINTS
run_simulation <- function(t, tf, num_I, num_S, num_R, N) {
S <- num_S
I <- num_I
R <- num_R
S_vals <- c(S)
I_vals <- c(I)
R_vals <- c(R)
time <- c(t)
while (t < tf) {
if (I == 0) {
break
}
infection_rate <- beta * I * S / N
recovery_rate <- mu * I
total_rate <- infection_rate + recovery_rate
dt <- -log(runif(1, min=0, max=1)) / total_rate
t = t + dt
if (runif(1, min=0, max=1) < infection_rate / total_rate) {
I <- I + 1
S <- S - 1
}
else {
I <- I - 1
R <- R + 1
}
S_vals <- c(S_vals, S)
I_vals <- c(I_vals, I)
R_vals <- c(R_vals, R)
time <- c(time, t)
}
run_df <- data.frame(time, S_vals, I_vals, R_vals)
#find S, I and R levels at set times and put in data frame to return from function
run.I.times <- approx(x = run_df$time,
y = run_df$I_vals,
xout = time_points,
method = "constant")
run.I.times.df <- data.frame(run.I.times[1], run.I.times[2])
colnames(run.I.times.df) <- c("time", "num_infected")
run.S.times <- approx(x = run_df$time,
y = run_df$S_vals,
xout = time_points,
method = "constant")
run.S.times.df <- data.frame(run.S.times[1], run.S.times[2])
colnames(run.S.times.df) <- c("time", "num_susceptible")
run.R.times <- approx(x = run_df$time,
y = run_df$R_vals,
xout = time_points,
method = "constant")
run.R.times.df <- data.frame(run.R.times[1], run.R.times[2])
colnames(run.R.times.df) <- c("time", "num_recovered")
return(list(run.I.times.df, run.S.times.df, run.R.times.df))
}
trajectory <- run_simulation(t, tf, num_I, num_S, num_R, N)
I_times <- trajectory[[1]]
S_times <- trajectory[[2]]
R_times <- trajectory[[3]]
trajectory[1]
bum_I
num_I
trajectory[1]
infection_rate <- beta * I * S / N
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
# delete everything
rm(list=ls(all=TRUE))
# import library for implementing Gillespie's algorithm
require(adaptivetau)
require(deSolve)
#SET TIMEFRAME FOR MODEL
t <- 0 #start time
tf <- 10
time_points <- seq(0, tf, by = 0.5)
num_runs <- 10
#SET INITIAL STATES AND PARAMETERS
num_S <- 9999
num_I <- 1
num_R <- 0
beta <- 2 #infection rate
mu = 1 #recovery rate
N <- num_S + num_I + num_R #total population
#FUNCTION TO IMPLEMENT GILLESPIE ALGORITHM AND RETURN NUMBERS OF S, I, R AT TIMEPOINTS
run_simulation <- function(t, tf, num_I, num_S, num_R, N, beta, mu) {
S <- num_S
I <- num_I
R <- num_R
S_vals <- c(S)
I_vals <- c(I)
R_vals <- c(R)
time <- c(t)
while (t < tf) {
if (I == 0) {
break
}
infection_rate <- beta * I * S / N
recovery_rate <- mu * I
total_rate <- infection_rate + recovery_rate
dt <- -log(runif(1, min=0, max=1)) / total_rate
t = t + dt
if (runif(1, min=0, max=1) < infection_rate / total_rate) {
I <- I + 1
S <- S - 1
}
else {
I <- I - 1
R <- R + 1
}
S_vals <- c(S_vals, S)
I_vals <- c(I_vals, I)
R_vals <- c(R_vals, R)
time <- c(time, t)
}
run_df <- data.frame(time, S_vals, I_vals, R_vals)
#find S, I and R levels at set times and put in data frame to return from function
run.I.times <- approx(x = run_df$time,
y = run_df$I_vals,
xout = time_points,
method = "constant")
run.I.times.df <- data.frame(run.I.times[1], run.I.times[2])
colnames(run.I.times.df) <- c("time", "num_infected")
run.S.times <- approx(x = run_df$time,
y = run_df$S_vals,
xout = time_points,
method = "constant")
run.S.times.df <- data.frame(run.S.times[1], run.S.times[2])
colnames(run.S.times.df) <- c("time", "num_susceptible")
run.R.times <- approx(x = run_df$time,
y = run_df$R_vals,
xout = time_points,
method = "constant")
run.R.times.df <- data.frame(run.R.times[1], run.R.times[2])
colnames(run.R.times.df) <- c("time", "num_recovered")
return(list(run.I.times.df, run.S.times.df, run.R.times.df))
}
trajectory <- run_simulation(t, tf, num_I, num_S, num_R, N, beta, mu)
View(trajectory)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
trajectory <- run_simulation(t, tf, num_I, num_S, num_R, N, beta, mu)
run_df <- data.frame(time, S_vals, I_vals, R_vals)
View(run_df)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
time_points <- seq(0, tf, by = 0.5)
time_points <- seq(0, tf, by = 0.5)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
# delete everything
rm(list=ls(all=TRUE))
# delete everything
rm(list=ls(all=TRUE))
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
run_df <- data.frame(time, S_vals, I_vals, R_vals)
?approx
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
View(run.I.times)
View(trajectory)
View(trajectory)
View(I_times)
View(S_times)
View(trajectory)
View(trajectory)
View(run_df)
View(run.I.times)
View(I_simulations)
View(I_simulations)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
View(I_simulations)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
recovery_rate <- mu * I
recovery_rate <- mu * I
recovery_rate <- mu * I
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
debugSource('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic_manual.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SI_model/SI_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SI_model/SI_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SI_model/SI_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SI_model/SI_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SI_model/SI_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SI_model/SI_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SI_model/SI_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SIR_model/SIR_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SI_model/SI_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Stochastic_models/SI_model/SI_stochastic.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
library(flux)
?flux
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
View(trajectory_df)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
View(trajectory_df)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Deterministic_model/2_patch_determ.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Stochastic_model/2_patch_stochast.R', echo=TRUE)
source('~/Dropbox/CAMBRIDGE/Part_2/Project/Two_patch_model/Stochastic_model/2_patch_stochast.R', echo=TRUE)
data = c(1,2,3,4)
data <- list(height = c(1,2,3), length = c(1,2,3))
data
datan <- filter(data, height <2)
datan <- filter(data[1], height <2)
datan <- filter(data[[1]], height <2)
data <- data.base(height = c(1,2,3), length = c(1,2,3))
data <- data.frame(height = c(1,2,3), length = c(1,2,3))
data_f <- filter(data, height <2)
data
data_f <- filter(data$height <2)
head(data)
data$height
data$height <2
filter(data, height <2)
filter(data, data$height <2)
install.packages(dplyr)
install.packages('dplyr')
library(dplyr)
filter(data, height <2)
filter(data, height != 2)
setwd("/Users/el")
setwd("/Users/elinfalla/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/")
file.edit("Apply1.R")
file.edit("Apply2.R")
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/Apply1.R', echo=TRUE)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/Apply2.R', echo=TRUE)
sum(v)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/Apply2.R', echo=TRUE)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/Apply2.R', echo=TRUE)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/Apply2.R', echo=TRUE)
?sum
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/Apply2.R', echo=TRUE)
file.edit("Sample.R")
## To run "num" iterations of the experiment using a for loop on a vector with preallocation
loopy_sample2 <- function(popn, n, num) {
result2 <- vector(num) #Preallocate expected size
for (i in 1:num) {
result2[i] <- myexperiment(popn, n)
}
return(result2)
}
loopy_sample2(rnorm(100), 20, 100)
loopy_sample2(rnorm(100), 20, 100)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/Sample.R', echo=TRUE)
## To run "num" iterations of the experiment using a for loop on a vector with preallocation
loopy_sample2 <- function(popn, n, num) {
result2 <- vector(,length=num) #Preallocate expected size
for (i in 1:num) {
result2[i] <- myexperiment(popn, n)
}
return(result2)
}
loopy_sample2(rnorm(100), 20, 100)
## To run "num" iterations of the experiment using a for loop on a vector with preallocation
loopy_sample2 <- function(popn, n, num) {
result2 <- vector(length=num) #Preallocate expected size
for (i in 1:num) {
result2[i] <- myexperiment(popn, n)
}
return(result2)
}
loopy_sample2(rnorm(100), 20, 100)
?lapply(list, function)
?lapply
## To run "num" iterations of the experiment using vectorisation with lapply
lapply_sample <- function(popn, n, num) {
result4 <- lapply(1:num, myexperiment(popn, n))
return(result4)
}
lapply_sample(rnorm(100), 20, 100)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/Sample.R', echo=TRUE)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/Sample.R', echo=TRUE)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/Sample.R', echo=TRUE)
lapply_sample(rnorm(100), 20, 100)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/Sample.R', echo=TRUE)
lapply_sample(rnorm(100), 20, 100)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/Sample.R', echo=TRUE)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/Sample.R', echo=TRUE)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/Sample.R', echo=TRUE)
source('~/Dropbox/2020-21/_Imperial_MSc/CMEECourseWork/Week3/Code/Sample.R', echo=TRUE)
x <- 1:20
x
y <- factor(rep(letters[1:5], each=4))
y
?factor
tapply(x,y,sum)
attatch(iris)
attach(iris)
iris
by(iris[,1:2], iris$Species, colMeans)
by(iris[,1:2], iris$Petal.Width, colMeans)
replicate(10, runif(5))
